Given an array of integers nums which is sorted in ascending order, and an 
integer target, write a function to search target in nums. If target exists, 
then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

case=1
input=6
-1 0 3 5 9 12
9
output=4

Explanation: 9 exists in nums and its index is 4

case=2
input=6
-1 0 3 5 9 12
2
output=-1

Explanation: 2 does not exist in nums so return -1

Sollution:
import java.util.*;
public class test{
    public static int  findindex(int arr[],int target){
        int n=arr.length;
        int left=0;
        int right=n-1;
        int index=0;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(arr[mid]==target){
                return mid;
            }
            else if(arr[mid]>target){
               right=mid-1;
            }
            else{
                left=mid+1;
            }
        }
        return -1;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int target=sc.nextInt();
        System.out.println(findindex(arr,target));
    }
}

Given a sorted array of distinct integers and a target value, return the index 
if the target is found. If not, return the index where it would be if it were 
inserted in order.

You must write an algorithm with O(log n) runtime complexity.

Sample test case

case=1
input=4
1 3 5 6
5
output=2

case=2
input=4
1 3 5 6
2
output=1

case=3
input=4
1 3 5 6
7
output=4


Solution:
import java.util.*;
public class test{
    public static int findindex(int arr[],int target){
        int left=0;
        int right=arr.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(arr[mid]==target){
                return mid;
            }
            else if(arr[mid]>target){
                right=mid-1;
                // if(arr[left]<target && target>arr[right]){
                    // return left+1;
                // }
            }
            else{
                left=mid+1;
                // if(arr[right]<target  && target>arr[left]){
                    // return right+1;
                // }
            }
        }
        return left;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int target=sc.nextInt();
        System.out.println(findindex(arr,target));
    }
}



Given a positive integer n, you can apply one of the following operations:

If n is even, replace n with n / 2.
If n is odd, replace n with either n + 1 or n - 1.
Return the minimum number of operations needed for n to become 1.

case=1
input=8
output=3
Explanation: 8 -> 4 -> 2 -> 1

case=2
input=7
output=4
Explanation: 7 -> 8 -> 4 -> 2 -> 1
or 7 -> 6 -> 3 -> 2 -> 1

case=3
input=4
output=2
Explanation: 4 -> 2 -> 1


import java.util.*;
public class test{
    public static int minOper(int n){
        int operations=0;
        while(n>1){
            if(n%2==0){
                n/=2;
            }
            else if((n+1)%4==0 && n!=3){
                n=n+1;
            }
            else{
                n=n-1;
            }
            operations++;
        }
        return operations;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(minOper(n));
    }
}



You have n coins and you want to build a staircase with these coins. 
The staircase consists of k rows where the ith row has exactly i coins. 
The last row of the staircase may be incomplete.

Given the integer n, return the number of complete rows of the staircase 
you will build.

Sample test case

case=1
input=5
output=2
Explanation: Because the 3rd row is incomplete, we return 2.

case=2
input=8
output=3
Explanation: Because the 4th row is incomplete, we return 3.

Approach: Using Binary Search (O(log n))

1.	We need to find the maximum number of complete rows k such that:
	1+2+3+...+k <=n
2.	This forms a sum of the first k natural numbers:
(k*(k+1))/2 <= n
3.	We can use binary search to efficiently find the largest k where this 
condition holds.

import java.util.*;
public class test{
    public static int staircase(int n){
        int l=0;
        int r=n-1;
        int count=0;
        while(l<=r){
            int mid=l+(r-l)/2;
            if((long)(mid*(mid+1))/2<=n){
                return mid;
            }
            else if(mid<n){
                count=mid;
                r=mid+1;
            }
            else{
                
                l=mid-1;
            }
        }
        return ans;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(staircase(n));
        
    }
}
