*************Loop based**********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use loop based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.


Solution:

import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            backtrack(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
    }
    public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) -
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element 
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
       System.out.println( generateSubsets(arr));
    }
}



**********Binary tree based without recursion********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Binary Tree based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test

{


    public static List<List<Integer>> generateSubsets(int arr[])

{


        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    

}
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result)

{

if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
}



  current.add(arr[i]);
  backtrack(arr,i+1,current,result);
  current.remove(current.size()-1);
  backtrack(arr,i+1,current,result);
    

}
  public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


    public static void main(String[] args)

{


        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)

{


            arr[i]=sc.nextInt();
        

}


       List<List<Integer>> result = generateSubsets(arr);

    sortListOfList(result);  // Sort the list of subsets

    System.out.println(result);
    

}

}



**********Binary tree with the recursion************
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Pure Recursion based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result){
    if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
    }
  List<Integer> includelist=new ArrayList<>(current);
  includelist.add(arr[i]);
  backtrack(arr,i+1,includelist,result);
  List<Integer> excludelist=new ArrayList<>(current);
  backtrack(arr,i+1,excludelist,result);
}
 public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
{
            arr[i]=sc.nextInt();
}
       List<List<Integer>> result = generateSubsets(arr);
    sortListOfList(result);  // Sort the list of subsets
    System.out.println(result);
}

}




*************NOW ACTUAL Hard Problems will start*********
The XOR total of an array is defined as the bitwise XOR of all its elements, 
or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting 
some (possibly zero) elements of b. 

Sample test case

case=1
input=2
1 3
output=6

Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6

case=2
input=3
5 1 6
output=28

Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

case=3
input=6
3 4 5 6 7 8
output=480

case=4
input=5
1 3 5 7 9
output=240

solution:

import java.util.*;
public class test{
    public static List<List<Integer>> subsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        recursionxor(arr,0,current,result);
        return result;
    }
    public static void recursionxor(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            recursionxor(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
        
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        // System.out.println(subsets(arr));
        List<List<Integer>> allSubsets = subsets(arr);
        int totalXorSum = 0;

        for (List<Integer> subset : allSubsets) 
            {
            int xor = 0;
            for (int num : subset) 
            {
                xor ^= num;
            }
            totalXorSum += xor;
            }
        System.out.println( totalXorSum);
    }
}


----------------------------Mixed Data structure problems-------------
/*
Given the root of a binary tree, return all root-to-leaf paths in any order.
A leaf is a node with no children.

Note: A Binary tree data structure is built from the user input and the root 
node is provided, you just need to implement the binaryTreePaths ()
An array element having value -1 represents NULL.

Sample test case
input=5
1 2 3 -1 5
output=[[1, 2, 5], [1, 3]]

      1
     / \
    2   3
     \
      5

Explanation: There are two paths from root to lead are 1->2->5 and 1->3

input=1
1
output=[[1]]


*/


import java.util.*;
class Solution
{
    List<List<Integer>> binaryTreePaths(Node node)
    {
        // Implement your code here     
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        // if(node==null){
        //     return result;
        // }
      backtrack(node,temp,result);
       
      
       
       return result;
    }
    public void backtrack(Node node,List<Integer> current,List<List<Integer>> result){
        if(node==null){
            return;
        }
        current.add(node.data);
        if(node.left==null && node.right==null){
            result.add(new ArrayList<>(current));
            
        }
        
        else{
         backtrack(node.left,current,result);
         
       backtrack(node.right,current,result);
        }
       current.remove(current.size()-1);
       
    }
}





/*
Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, f
ind all possible paths from node 0 to node n - 1 and return them in any order.

A graph is created and represented in the form of adjacency list is provided.
Note: you just need to implement the allPaths() method.

case=1
input=4 4
0 1
0 2
1 3
2 3
0 3
output=[[0, 1, 3], [0, 2, 3]]

Explanation: The first line contains number of nodes and number of edges. 
Followed by edges (start, end). Finally, the start node and destination node 
in the graph.

class Graph
{
    int vertices;
    List<Integer> adj[];
}
*/

import java.util.*;
class Solution
{
    // Parameters -> graph, start node, destination node
    List<List<Integer>> allPaths(Graph g, int s, int d)
    {
        // Implement your code here
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(g,s,d,result,temp);
        return result;
        
    }
    public void backtrack(Graph g,int start,int dest,List<List<Integer>> result,List<Integer> temp){
        
        temp.add(start);
        if(start==dest){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int neigh:g.adj[start]){
            backtrack(g,neigh,dest,result,temp);
            temp.remove(temp.size()-1);
            
        }
    }
   
}



Given an array nums of distinct integers, return all the possible permutations. 
You can return the answer in any order.

case=1
input=3
1 2 3
output=[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

Explanation:
Input: The first line is the number of elements, followed by their values.
Output: All possible permutations

case=2
input=2
0 1
output=[[0, 1], [1, 0]]

Note: The below function sorts a list of lists. You can use this to sort the 
subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


Solution:
import java.util.*;
public class test{
    public static List<List<Integer>> permutations(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
         boolean visited[]=new boolean[arr.length];
        backtrack(arr,current,result,visited);
        return result;
    }
    public static void backtrack(int arr[],List<Integer> current,List<List<Integer>> result,boolean visited[]){
       
        if(current.size()==arr.length){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=0;i<arr.length;i++){
            if(!visited[i]){
                visited[i]=true;
                current.add(arr[i]);
                backtrack(arr,current,result,visited);
                current.remove(current.size()-1);
                visited[i]=false;
            }
            // current.add(arr[i]);
            // backtrack(arr,i+1,current,result);
            // current.remove(current.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(permutations(arr));
    }
}






