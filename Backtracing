*************Loop based**********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use loop based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.


Solution:

import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            backtrack(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
    }
    public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) -
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element 
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
       System.out.println( generateSubsets(arr));
    }
}



**********Binary tree based without recursion********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Binary Tree based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test

{


    public static List<List<Integer>> generateSubsets(int arr[])

{


        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    

}
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result)

{

if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
}



  current.add(arr[i]);
  backtrack(arr,i+1,current,result);
  current.remove(current.size()-1);
  backtrack(arr,i+1,current,result);
    

}
  public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


    public static void main(String[] args)

{


        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)

{


            arr[i]=sc.nextInt();
        

}


       List<List<Integer>> result = generateSubsets(arr);

    sortListOfList(result);  // Sort the list of subsets

    System.out.println(result);
    

}

}



**********Binary tree with the recursion************
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Pure Recursion based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result){
    if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
    }
  List<Integer> includelist=new ArrayList<>(current);
  includelist.add(arr[i]);
  backtrack(arr,i+1,includelist,result);
  List<Integer> excludelist=new ArrayList<>(current);
  backtrack(arr,i+1,excludelist,result);
}
 public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
{
            arr[i]=sc.nextInt();
}
       List<List<Integer>> result = generateSubsets(arr);
    sortListOfList(result);  // Sort the list of subsets
    System.out.println(result);
}

}




*************NOW ACTUAL Hard Problems will start*********
The XOR total of an array is defined as the bitwise XOR of all its elements, 
or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting 
some (possibly zero) elements of b. 

Sample test case

case=1
input=2
1 3
output=6

Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6

case=2
input=3
5 1 6
output=28

Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

case=3
input=6
3 4 5 6 7 8
output=480

case=4
input=5
1 3 5 7 9
output=240

solution:

import java.util.*;
public class test{
    public static List<List<Integer>> subsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        recursionxor(arr,0,current,result);
        return result;
    }
    public static void recursionxor(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            recursionxor(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
        
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        // System.out.println(subsets(arr));
        List<List<Integer>> allSubsets = subsets(arr);
        int totalXorSum = 0;

        for (List<Integer> subset : allSubsets) 
            {
            int xor = 0;
            for (int num : subset) 
            {
                xor ^= num;
            }
            totalXorSum += xor;
            }
        System.out.println( totalXorSum);
    }
}


----------------------------Mixed Data structure problems-------------
/*
Given the root of a binary tree, return all root-to-leaf paths in any order.
A leaf is a node with no children.

Note: A Binary tree data structure is built from the user input and the root 
node is provided, you just need to implement the binaryTreePaths ()
An array element having value -1 represents NULL.

Sample test case
input=5
1 2 3 -1 5
output=[[1, 2, 5], [1, 3]]

      1
     / \
    2   3
     \
      5

Explanation: There are two paths from root to lead are 1->2->5 and 1->3

input=1
1
output=[[1]]


*/


import java.util.*;
class Solution
{
    List<List<Integer>> binaryTreePaths(Node node)
    {
        // Implement your code here     
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        // if(node==null){
        //     return result;
        // }
      backtrack(node,temp,result);
       
      
       
       return result;
    }
    public void backtrack(Node node,List<Integer> current,List<List<Integer>> result){
        if(node==null){
            return;
        }
        current.add(node.data);
        if(node.left==null && node.right==null){
            result.add(new ArrayList<>(current));
            
        }
        
        else{
         backtrack(node.left,current,result);
         
       backtrack(node.right,current,result);
        }
       current.remove(current.size()-1);
       
    }
}





/*
Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, f
ind all possible paths from node 0 to node n - 1 and return them in any order.

A graph is created and represented in the form of adjacency list is provided.
Note: you just need to implement the allPaths() method.

case=1
input=4 4
0 1
0 2
1 3
2 3
0 3
output=[[0, 1, 3], [0, 2, 3]]

Explanation: The first line contains number of nodes and number of edges. 
Followed by edges (start, end). Finally, the start node and destination node 
in the graph.

class Graph
{
    int vertices;
    List<Integer> adj[];
}
*/

import java.util.*;
class Solution
{
    // Parameters -> graph, start node, destination node
    List<List<Integer>> allPaths(Graph g, int s, int d)
    {
        // Implement your code here
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(g,s,d,result,temp);
        return result;
        
    }
    public void backtrack(Graph g,int start,int dest,List<List<Integer>> result,List<Integer> temp){
        
        temp.add(start);
        if(start==dest){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int neigh:g.adj[start]){
            backtrack(g,neigh,dest,result,temp);
            temp.remove(temp.size()-1);
            
        }
    }
   
}



Given an array nums of distinct integers, return all the possible permutations. 
You can return the answer in any order.

case=1
input=3
1 2 3
output=[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

Explanation:
Input: The first line is the number of elements, followed by their values.
Output: All possible permutations

case=2
input=2
0 1
output=[[0, 1], [1, 0]]

Note: The below function sorts a list of lists. You can use this to sort the 
subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


Solution:
import java.util.*;
public class test{
    public static List<List<Integer>> permutations(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
         boolean visited[]=new boolean[arr.length];
        backtrack(arr,current,result,visited);
        return result;
    }
    public static void backtrack(int arr[],List<Integer> current,List<List<Integer>> result,boolean visited[]){
       
        if(current.size()==arr.length){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=0;i<arr.length;i++){
            if(!visited[i]){
                visited[i]=true;
                current.add(arr[i]);
                backtrack(arr,current,result,visited);
                current.remove(current.size()-1);
                visited[i]=false;
            }
            // current.add(arr[i]);
            // backtrack(arr,i+1,current,result);
            // current.remove(current.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(permutations(arr));
    }
}





Given a set of positive numbers, determine if there exists a subset whose 
sum is equal to a given number ‘S’.

Example:
Input: {1, 2, 3, 7}, S=6
Output: True

Explanation: The given set has a subset whose sum is '6': {1, 2, 3}

Sample test case
case=1
input=4
1 2 3 7
6
output=true


import java.util.*;
public class test{
    public static boolean isSubset(int arr[],int s){
        int n=arr.length;
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(arr,0,result,temp);
        
        
        for(List<Integer> tempsum:result){
            int sum=0;
            for(Integer num:tempsum){
                sum=sum+num;
                if(sum==s){
                    return true;
                }
            }
           
        }
         return false;
    }
    public static void backtrack(int arr[],int start,List<List<Integer>> result,List<Integer> temp){
        result.add(new ArrayList<>(temp));
        for(int i=start;i<arr.length;i++){
            temp.add(arr[i]);
            // int sum+=arr[i];
            backtrack(arr,i+1,result,temp);
            temp.remove(temp.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        
        int s=sc.nextInt();
        System.out.println(isSubset(arr, s));
    }
}


Given a string containing digits from 2-9 inclusive, return all possible 
letter combinations that the number could represent.
A mapping of digits to letters (just like on the telephone buttons) 
is given below. 
2-> a, b, c
3-> d, e, f
4-> g, h, i
5-> j, k, l
6-> m, n, o
7-> p, q, r, s
8-> t, u, v
9-> w, x, y, z

Note that 1 does not map to any letters. The result should be in ascending order.
 

case=1
input=2
output=[a, b, c]

case=2
input=23
output=[ad, ae, af, bd, be, bf, cd, ce, cf]

import java.util.*;

public class test {
    public static List<String> letterCombinations(String str) {
        List<String> result = new ArrayList<>();
        if (str.length() == 0) return result;
        HashMap<Character, String> hm = new HashMap<>();
        hm.put('2', "abc"); hm.put('3', "def"); hm.put('4', "ghi");
        hm.put('5', "jkl"); hm.put('6', "mno"); hm.put('7', "pqrs");
        hm.put('8', "tuv"); hm.put('9', "wxyz");
        backtrack(str, 0, new StringBuilder(), hm, result);
        return result;
    }

    public static void backtrack(String str, int index, StringBuilder path, HashMap<Character, String> hm, List<String> result) {
        if (index == str.length()) {
            result.add(path.toString());
            return;
        }
        String letters = hm.get(str.charAt(index));
        if (letters == null) return;
        for (char letter : letters.toCharArray()) {
            path.append(letter);
            backtrack(str, index + 1, path, hm, result);
            path.deleteCharAt(path.length() - 1);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        List<String> combinations = letterCombinations(str);
        System.out.println(combinations);
    }
}


Given two integers n and k, return all possible combinations of k numbers 
chosen from the range [1, n].
You may return the answer in any order.

case=1
input=4 2
output=[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered 
to be the same combination.

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
{
    Collections.sort(Subsets, (a, b) ->
    {
        int sizeA = a.size();
        int sizeB = b.size();

        // Compare element by element
        for (int i = 0; i < Math.min(sizeA, sizeB); i++)
        {
            if (!a.get(i).equals(b.get(i)))
            {
                return a.get(i) - b.get(i);
            }
        }

        // If all elements are equal, compare by size
        return sizeA - sizeB;
    });
}

case=2
input=1 1
output=[[1]]
Explanation: There is 1 choose 1 = 1 total combination.



import java.util.*;
public class test{
    public static List<List<Integer>> combinations(int n,int k){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(n,k,result,current,1);
        sortListOfList(result);
        return result;
    }
    public static void backtrack(int n,int k,List<List<Integer>> result,List<Integer> current,int start){
        
        if(current.size()==k){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=start;i<=n;i++){
            current.add(i);
            backtrack(n,k,result,current,i+1);
            current.remove(current.size()-1);
            }
        }
    
    public static void sortListOfList(List<List<Integer>> result)
{
    Collections.sort(result, (a, b) ->
    {
        int sizeA = a.size();
        int sizeB = b.size();

        // Compare element by element
        for (int i = 0; i < Math.min(sizeA, sizeB); i++)
        {
            if (!a.get(i).equals(b.get(i)))
            {
                return a.get(i) - b.get(i);
            }
        }

        // If all elements are equal, compare by size
        return sizeA - sizeB;
    });
}
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        System.out.println(combinations(n,k));
        
    }
}



Given an array of distinct integers candidates and a target integer target, 
return a list of all unique combinations of candidates where the chosen numbers 
sum to target. You may return the combinations in any order.

The same number may be chosen from candidates an unlimited number of times. 
Two combinations are unique if the frequency of at least one of the chosen 
numbers is different.

The test cases are generated such that the number of unique combinations that 
sum up to target is less than 150 combinations for the given input.

case=1
input=4
2 3 8 7
7
output=[[2, 2, 3], [7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

case=2
input=3
2 3 5
8
output=[[2, 2, 2, 2], [2, 3, 3], [3, 5]]

case=3
input=1
2
1
output=[]



import java.util.*;
public class test{
    public static List<List<Integer>> combinations(int arr[],int target){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        
        
        backtrack(arr,0,temp,result,target);
        return result;
    }
    public  static void backtrack(int arr[],int index,List<Integer> temp,List<List<Integer>> result,int target){
        
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        if(target<0){
            return;
        }
        for(int i=index;i<arr.length;i++){
            temp.add(arr[i]);
            backtrack(arr,i,temp,result,target-arr[i]);
            temp.remove(temp.size()-1);
            
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
            
        }
        int target=sc.nextInt();
        System.out.println(combinations(arr,target));
    }
}




The n-queens puzzle is the problem of placing n queens on an n x n chessboard 
such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. 
You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens' 
placement, where 'Q' and '.' both indicate a queen and an empty space, 
respectively.

case=1
input=4
output=[[.Q.., ...Q, Q..., ..Q.], [..Q., Q..., ...Q, .Q..]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as 
shown above

case=2
input=1
output=[[Q]]


import java.util.*;
public class test{
    public static void solveNQueens(int n) {
        List<List<String>> results = new ArrayList<>();
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        solve(0, board, results, n);
        System.out.print(results);
    }
    static void solve(int row, char[][] board, List<List<String>> results, int n) {
        if (row == n) {
            results.add(constructBoard(board));
            return;
            }

        for (int col = 0; col < n; col++){
            if (isSafe(row, col, board, n)){
                board[row][col] = 'Q';
                solve(row + 1, board, results, n);
                board[row][col] = '.';
            }
        }
    }
    private static boolean isSafe(int row, int col, char[][] board, int n) {
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
            }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
                }
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
            if (board[i][j] == 'Q') return false;
            }

        return true;
        }

    private static List<String> constructBoard(char[][] board){
        List<String> al = new ArrayList<>();
        for (char[] row : board){

            al.add(new String(row));
            }
        return al;
        }
 public static void main(String[] args) {
       Scanner sc = new Scanner(System.in);
       int n = sc.nextInt();
       solveNQueens(n);
    
}

}







Given n pairs of parentheses, write a function to generate all combinations 
of well-formed parentheses.

case=1
input=3
output=[((())), (()()), (())(), ()(()), ()()()]

case=2
input=1
output=[()]


import java.util.*;
public class test

{


    public static List<String> generateParenthesis(int n)

{


        List<String> result=new ArrayList<>();
        if(n==0)

{


            return result;
        

}
        backtrack(n,0,0,new StringBuilder(""),result);
        return result;
    

}
    
    private static void backtrack(int n,int open,int close,StringBuilder path,List<String> result)

{


        
        if(path.length()==2*n)

{


            result.add(path.toString());
            return;
        

}
        
        if(open<n)

{
          
          
            path.append('(');
            backtrack(n,open+1,close,path,result);
            path.deleteCharAt(path.length()-1);
        

}
        if(close<open)

{           
    

            path.append(")");
            backtrack(n,open,close+1,path,result);
            path.deleteCharAt(path.length()-1);
}
}
    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(generateParenthesis(n));

}

}


Given an m x n grid of characters board and a string word, return true if 
word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, 
where adjacent cells are horizontally or vertically neighboring. The same 
letter cell may not be used more than once.

Sample test case

case=1
input=3 4
A B C E
S F C S
A D E E
ABCCED
output=true

case=2
input=3 4
A B C E
S F C S
A D E E
SEE
output=true


import java.util.*;

public class test 

{


    public static boolean willExists(char[][] board, String target) 

{


        int rows = board.length;
        int cols = board[0].length;
        boolean[][] visited = new boolean[rows][cols];

        for (int i = 0; i < rows; i++) 

{


            for (int j = 0; j < cols; j++) 

{


                if (board[i][j] == target.charAt(0)) 

{


                    if (backtrack(board, target, i, j, 0, visited)) 

{


                        return true;
                    

}
                

}
            

}
        

}
        return false; // moved outside the loop
    

}

    public static boolean backtrack(char[][] board, String target, int row, int col, int index, boolean[][] visited) 

{


        if (index == target.length()) return true;

        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length
                || board[row][col] != target.charAt(index) || visited[row][col]) 

{


            return false;
        

}

        visited[row][col] = true;

        boolean found = backtrack(board, target, row + 1, col, index + 1, visited) ||
                        backtrack(board, target, row - 1, col, index + 1, visited) ||
                        backtrack(board, target, row, col + 1, index + 1, visited) ||
                        backtrack(board, target, row, col - 1, index + 1, visited);

        visited[row][col] = false; // backtrack
        return found;
    

}

    public static void main(String[] args) 

{


        Scanner sc = new Scanner(System.in);
        int rows = sc.nextInt();
        int cols = sc.nextInt();
        char[][] board = new char[rows][cols];

        for (int i = 0; i < rows; i++) 

{


            for (int j = 0; j < cols; j++) 

{


                board[i][j] = sc.next().charAt(0);
            

}
        

}

        sc.nextLine(); // consume newline
        String target = sc.nextLine();
        System.out.println(willExists(board, target));
    

}

}

Given a positive integer n, return the punishment number of n.

The punishment number of n is defined as the sum of the squares of all 
integers i such that:

1 <= i <= n
The decimal representation of i * i can be partitioned into contiguous 
substrings such that the sum of the integer values of these substrings equals i.

case=1
input=10
output=182
Explanation: There are exactly 3 integers i in the range [1, 10] that 
satisfy the conditions in the statement:
- 1 since 1 * 1 = 1
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 and 1 with a sum 
equal to 8 + 1 == 9.
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 and 0 with a 
sum equal to 10 + 0 == 10.
Hence, the punishment number of 10 is 1 + 81 + 100 = 182

case=2
input=37
output=1478
Explanation: There are exactly 4 integers i in the range [1, 37] that satisfy 
the conditions in the statement:
- 1 since 1 * 1 = 1. 
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. 
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. 
- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.
Hence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478



import java.util.*;
public class test{
    public static int punishmentNumber(int n){
        int result=0;
        for(int i=1;i<=n;i++){
            int square=i*i;
            if (cansplit(String.valueOf(square),0,i)){
                result+=square;
                
            }
        }
      return result;
        
    }
    public static boolean cansplit(String squarestring,int index,int target){
        if(index==squarestring.length()){
            return target==0;
        }
        
        
        for(int i=index+1;i<=squarestring.length();i++){
            int x=Integer.parseInt(squarestring.substring(index,i));
            if(x>target){
                continue;
            }
            if(cansplit(squarestring,i,target-x)){
                return true;
            }
            
            
        }
        return false;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        
        System.out.println(punishmentNumber(n));
    }
}




You are given a 0-indexed string pattern of length n consisting of the 
characters 'I' meaning increasing and 'D' meaning decreasing.

A 0-indexed string num of length n + 1 is created using the following conditions:

num consists of the digits '1' to '9', where each digit is used at most once.
If pattern[i] == 'I', then num[i] < num[i + 1].
If pattern[i] == 'D', then num[i] > num[i + 1].
Return the lexicographically smallest possible string num that meets the 
conditions.

case=1
input=IIIDIDDD
output=123549876
Explanation:
At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].
At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].
Some possible values of num are "245639871", "135749862", and "123849765".
It can be proven that "123549876" is the smallest possible num that meets 
the conditions.
Note that "123414321" is not possible because the digit '1' is used more than once.

case=2
input=DDD
output=4321
Explanation:
Some possible values of num are "9876", "7321", and "8742".
It can be proven that "4321" is the smallest possible num that meets the 
conditions.









