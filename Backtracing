*************Loop based**********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use loop based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.


Solution:

import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            backtrack(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
    }
    public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) -
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element 
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
       System.out.println( generateSubsets(arr));
    }
}



**********Binary tree based without recursion********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Binary Tree based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test

{


    public static List<List<Integer>> generateSubsets(int arr[])

{


        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    

}
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result)

{

if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
}



  current.add(arr[i]);
  backtrack(arr,i+1,current,result);
  current.remove(current.size()-1);
  backtrack(arr,i+1,current,result);
    

}
  public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


    public static void main(String[] args)

{


        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)

{


            arr[i]=sc.nextInt();
        

}


       List<List<Integer>> result = generateSubsets(arr);

    sortListOfList(result);  // Sort the list of subsets

    System.out.println(result);
    

}

}



**********Binary tree with the recursion************
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Pure Recursion based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result){
    if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
    }
  List<Integer> includelist=new ArrayList<>(current);
  includelist.add(arr[i]);
  backtrack(arr,i+1,includelist,result);
  List<Integer> excludelist=new ArrayList<>(current);
  backtrack(arr,i+1,excludelist,result);
}
 public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
{
            arr[i]=sc.nextInt();
}
       List<List<Integer>> result = generateSubsets(arr);
    sortListOfList(result);  // Sort the list of subsets
    System.out.println(result);
}

}




*************NOW ACTUAL Hard Problems will start*********
The XOR total of an array is defined as the bitwise XOR of all its elements, 
or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting 
some (possibly zero) elements of b. 

Sample test case

case=1
input=2
1 3
output=6

Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6

case=2
input=3
5 1 6
output=28

Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

case=3
input=6
3 4 5 6 7 8
output=480

case=4
input=5
1 3 5 7 9
output=240

solution:

import java.util.*;
public class test{
    public static List<List<Integer>> subsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        recursionxor(arr,0,current,result);
        return result;
    }
    public static void recursionxor(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            recursionxor(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
        
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        // System.out.println(subsets(arr));
        List<List<Integer>> allSubsets = subsets(arr);
        int totalXorSum = 0;

        for (List<Integer> subset : allSubsets) 
            {
            int xor = 0;
            for (int num : subset) 
            {
                xor ^= num;
            }
            totalXorSum += xor;
            }
        System.out.println( totalXorSum);
    }
}


----------------------------Mixed Data structure problems-------------
/*
Given the root of a binary tree, return all root-to-leaf paths in any order.
A leaf is a node with no children.

Note: A Binary tree data structure is built from the user input and the root 
node is provided, you just need to implement the binaryTreePaths ()
An array element having value -1 represents NULL.

Sample test case
input=5
1 2 3 -1 5
output=[[1, 2, 5], [1, 3]]

      1
     / \
    2   3
     \
      5

Explanation: There are two paths from root to lead are 1->2->5 and 1->3

input=1
1
output=[[1]]


*/


import java.util.*;
class Solution
{
    List<List<Integer>> binaryTreePaths(Node node)
    {
        // Implement your code here     
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        // if(node==null){
        //     return result;
        // }
      backtrack(node,temp,result);
       
      
       
       return result;
    }
    public void backtrack(Node node,List<Integer> current,List<List<Integer>> result){
        if(node==null){
            return;
        }
        current.add(node.data);
        if(node.left==null && node.right==null){
            result.add(new ArrayList<>(current));
            
        }
        
        else{
         backtrack(node.left,current,result);
         
       backtrack(node.right,current,result);
        }
       current.remove(current.size()-1);
       
    }
}





/*
Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, f
ind all possible paths from node 0 to node n - 1 and return them in any order.

A graph is created and represented in the form of adjacency list is provided.
Note: you just need to implement the allPaths() method.

case=1
input=4 4
0 1
0 2
1 3
2 3
0 3
output=[[0, 1, 3], [0, 2, 3]]

Explanation: The first line contains number of nodes and number of edges. 
Followed by edges (start, end). Finally, the start node and destination node 
in the graph.

class Graph
{
    int vertices;
    List<Integer> adj[];
}
*/

import java.util.*;
class Solution
{
    // Parameters -> graph, start node, destination node
    List<List<Integer>> allPaths(Graph g, int s, int d)
    {
        // Implement your code here
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(g,s,d,result,temp);
        return result;
        
    }
    public void backtrack(Graph g,int start,int dest,List<List<Integer>> result,List<Integer> temp){
        
        temp.add(start);
        if(start==dest){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int neigh:g.adj[start]){
            backtrack(g,neigh,dest,result,temp);
            temp.remove(temp.size()-1);
            
        }
    }
   
}



Given an array nums of distinct integers, return all the possible permutations. 
You can return the answer in any order.

case=1
input=3
1 2 3
output=[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

Explanation:
Input: The first line is the number of elements, followed by their values.
Output: All possible permutations

case=2
input=2
0 1
output=[[0, 1], [1, 0]]

Note: The below function sorts a list of lists. You can use this to sort the 
subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


Solution:
import java.util.*;
public class test{
    public static List<List<Integer>> permutations(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
         boolean visited[]=new boolean[arr.length];
        backtrack(arr,current,result,visited);
        return result;
    }
    public static void backtrack(int arr[],List<Integer> current,List<List<Integer>> result,boolean visited[]){
       
        if(current.size()==arr.length){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=0;i<arr.length;i++){
            if(!visited[i]){
                visited[i]=true;
                current.add(arr[i]);
                backtrack(arr,current,result,visited);
                current.remove(current.size()-1);
                visited[i]=false;
            }
            // current.add(arr[i]);
            // backtrack(arr,i+1,current,result);
            // current.remove(current.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(permutations(arr));
    }
}





Given a set of positive numbers, determine if there exists a subset whose 
sum is equal to a given number ‘S’.

Example:
Input: {1, 2, 3, 7}, S=6
Output: True

Explanation: The given set has a subset whose sum is '6': {1, 2, 3}

Sample test case
case=1
input=4
1 2 3 7
6
output=true


import java.util.*;
public class test{
    public static boolean isSubset(int arr[],int s){
        int n=arr.length;
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(arr,0,result,temp);
        
        
        for(List<Integer> tempsum:result){
            int sum=0;
            for(Integer num:tempsum){
                sum=sum+num;
                if(sum==s){
                    return true;
                }
            }
           
        }
         return false;
    }
    public static void backtrack(int arr[],int start,List<List<Integer>> result,List<Integer> temp){
        result.add(new ArrayList<>(temp));
        for(int i=start;i<arr.length;i++){
            temp.add(arr[i]);
            // int sum+=arr[i];
            backtrack(arr,i+1,result,temp);
            temp.remove(temp.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        
        int s=sc.nextInt();
        System.out.println(isSubset(arr, s));
    }
}


Given a string containing digits from 2-9 inclusive, return all possible 
letter combinations that the number could represent.
A mapping of digits to letters (just like on the telephone buttons) 
is given below. 
2-> a, b, c
3-> d, e, f
4-> g, h, i
5-> j, k, l
6-> m, n, o
7-> p, q, r, s
8-> t, u, v
9-> w, x, y, z

Note that 1 does not map to any letters. The result should be in ascending order.
 

case=1
input=2
output=[a, b, c]

case=2
input=23
output=[ad, ae, af, bd, be, bf, cd, ce, cf]

import java.util.*;

public class test {
    public static List<String> letterCombinations(String str) {
        List<String> result = new ArrayList<>();
        if (str.length() == 0) return result;
        HashMap<Character, String> hm = new HashMap<>();
        hm.put('2', "abc"); hm.put('3', "def"); hm.put('4', "ghi");
        hm.put('5', "jkl"); hm.put('6', "mno"); hm.put('7', "pqrs");
        hm.put('8', "tuv"); hm.put('9', "wxyz");
        backtrack(str, 0, new StringBuilder(), hm, result);
        return result;
    }

    public static void backtrack(String str, int index, StringBuilder path, HashMap<Character, String> hm, List<String> result) {
        if (index == str.length()) {
            result.add(path.toString());
            return;
        }
        String letters = hm.get(str.charAt(index));
        if (letters == null) return;
        for (char letter : letters.toCharArray()) {
            path.append(letter);
            backtrack(str, index + 1, path, hm, result);
            path.deleteCharAt(path.length() - 1);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        List<String> combinations = letterCombinations(str);
        System.out.println(combinations);
    }
}


Given two integers n and k, return all possible combinations of k numbers 
chosen from the range [1, n].
You may return the answer in any order.

case=1
input=4 2
output=[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered 
to be the same combination.

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
{
    Collections.sort(Subsets, (a, b) ->
    {
        int sizeA = a.size();
        int sizeB = b.size();

        // Compare element by element
        for (int i = 0; i < Math.min(sizeA, sizeB); i++)
        {
            if (!a.get(i).equals(b.get(i)))
            {
                return a.get(i) - b.get(i);
            }
        }

        // If all elements are equal, compare by size
        return sizeA - sizeB;
    });
}

case=2
input=1 1
output=[[1]]
Explanation: There is 1 choose 1 = 1 total combination.



import java.util.*;
public class test{
    public static List<List<Integer>> combinations(int n,int k){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(n,k,result,current,1);
        sortListOfList(result);
        return result;
    }
    public static void backtrack(int n,int k,List<List<Integer>> result,List<Integer> current,int start){
        
        if(current.size()==k){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=start;i<=n;i++){
            current.add(i);
            backtrack(n,k,result,current,i+1);
            current.remove(current.size()-1);
            }
        }
    
    public static void sortListOfList(List<List<Integer>> result)
{
    Collections.sort(result, (a, b) ->
    {
        int sizeA = a.size();
        int sizeB = b.size();

        // Compare element by element
        for (int i = 0; i < Math.min(sizeA, sizeB); i++)
        {
            if (!a.get(i).equals(b.get(i)))
            {
                return a.get(i) - b.get(i);
            }
        }

        // If all elements are equal, compare by size
        return sizeA - sizeB;
    });
}
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        System.out.println(combinations(n,k));
        
    }
}



Given an array of distinct integers candidates and a target integer target, 
return a list of all unique combinations of candidates where the chosen numbers 
sum to target. You may return the combinations in any order.

The same number may be chosen from candidates an unlimited number of times. 
Two combinations are unique if the frequency of at least one of the chosen 
numbers is different.

The test cases are generated such that the number of unique combinations that 
sum up to target is less than 150 combinations for the given input.

case=1
input=4
2 3 8 7
7
output=[[2, 2, 3], [7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

case=2
input=3
2 3 5
8
output=[[2, 2, 2, 2], [2, 3, 3], [3, 5]]

case=3
input=1
2
1
output=[]



import java.util.*;
public class test{
    public static List<List<Integer>> combinations(int arr[],int target){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        
        
        backtrack(arr,0,temp,result,target);
        return result;
    }
    public  static void backtrack(int arr[],int index,List<Integer> temp,List<List<Integer>> result,int target){
        
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        if(target<0){
            return;
        }
        for(int i=index;i<arr.length;i++){
            temp.add(arr[i]);
            backtrack(arr,i,temp,result,target-arr[i]);
            temp.remove(temp.size()-1);
            
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
            
        }
        int target=sc.nextInt();
        System.out.println(combinations(arr,target));
    }
}




The n-queens puzzle is the problem of placing n queens on an n x n chessboard 
such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. 
You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens' 
placement, where 'Q' and '.' both indicate a queen and an empty space, 
respectively.

case=1
input=4
output=[[.Q.., ...Q, Q..., ..Q.], [..Q., Q..., ...Q, .Q..]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as 
shown above

case=2
input=1
output=[[Q]]


import java.util.*;
public class test{
    public static void solveNQueens(int n) {
        List<List<String>> results = new ArrayList<>();
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        solve(0, board, results, n);
        System.out.print(results);
    }
    static void solve(int row, char[][] board, List<List<String>> results, int n) {
        if (row == n) {
            results.add(constructBoard(board));
            return;
            }

        for (int col = 0; col < n; col++){
            if (isSafe(row, col, board, n)){
                board[row][col] = 'Q';
                solve(row + 1, board, results, n);
                board[row][col] = '.';
            }
        }
    }
    private static boolean isSafe(int row, int col, char[][] board, int n) {
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
            }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
                }
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
            if (board[i][j] == 'Q') return false;
            }

        return true;
        }

    private static List<String> constructBoard(char[][] board){
        List<String> al = new ArrayList<>();
        for (char[] row : board){

            al.add(new String(row));
            }
        return al;
        }
 public static void main(String[] args) {
       Scanner sc = new Scanner(System.in);
       int n = sc.nextInt();
       solveNQueens(n);
    
}

}







Given n pairs of parentheses, write a function to generate all combinations 
of well-formed parentheses.

case=1
input=3
output=[((())), (()()), (())(), ()(()), ()()()]

case=2
input=1
output=[()]


class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result=new ArrayList<>();
        if(n==0){
            return result;
        }
        backtrack(n,0,0,"", result);

         return result;
        
    }
    private void backtrack(int n,int open,int close,String str,List<String> result){

        if(str.length()==n*2){
            result.add(str);
            return;
        }
         
         if(open<n){
            backtrack(n,open+1,close,str+"(",result);

         }
         if(close<open){
            backtrack(n,open,close+1,str+")",result);
         }
    }
}

Given an m x n grid of characters board and a string word, return true if 
word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, 
where adjacent cells are horizontally or vertically neighboring. The same 
letter cell may not be used more than once.

Sample test case

case=1
input=3 4
A B C E
S F C S
A D E E
ABCCED
output=true

case=2
input=3 4
A B C E
S F C S
A D E E
SEE
output=true


class Solution {
    public boolean exist(char[][] board, String word) {
        
        int rows=board.length;
        int cols=board[0].length;
        boolean visited[][]=new boolean[rows][cols];
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(board[i][j]==word.charAt(0)){
                    if(backtrack(board,word,i,j,0,visited)){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    boolean backtrack(char board[][],String word,int rows,int cols,int index,boolean visited[][]){
        if(index==word.length()){
           return true;
        }
           //basecase
        if(rows<0 || rows>=board.length || cols<0 || cols>=board[0].length || visited[rows][cols]==true || board[rows][cols]!=word.charAt(index)){
            return false;
        }
        visited[rows][cols]=true;
      boolean found=  backtrack(board,word,rows-1,cols,index+1,visited)||
        backtrack(board,word,rows+1,cols,index+1,visited)||
        backtrack(board,word,rows,cols+1,index+1,visited)||
        backtrack(board,word,rows,cols-1,index+1,visited);
        //backtracking step
        visited[rows][cols]=false;

      return found;
    }
}

Given a positive integer n, return the punishment number of n.

The punishment number of n is defined as the sum of the squares of all 
integers i such that:

1 <= i <= n
The decimal representation of i * i can be partitioned into contiguous 
substrings such that the sum of the integer values of these substrings equals i.

case=1
input=10
output=182
Explanation: There are exactly 3 integers i in the range [1, 10] that 
satisfy the conditions in the statement:
- 1 since 1 * 1 = 1
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 and 1 with a sum 
equal to 8 + 1 == 9.
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 and 0 with a 
sum equal to 10 + 0 == 10.
Hence, the punishment number of 10 is 1 + 81 + 100 = 182

case=2
input=37
output=1478
Explanation: There are exactly 4 integers i in the range [1, 37] that satisfy 
the conditions in the statement:
- 1 since 1 * 1 = 1. 
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. 
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. 
- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.
Hence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478



import java.util.*;
public class test{
    public static int punishmentNumber(int n){
        int result=0;
        for(int i=1;i<=n;i++){
            int square=i*i;
            if (cansplit(String.valueOf(square),0,i)){
                result+=square;
                
            }
        }
      return result;
        
    }
    public static boolean cansplit(String squarestring,int index,int target){
        if(index==squarestring.length()){
            return target==0;
        }
        
        
        for(int i=index+1;i<=squarestring.length();i++){
            int x=Integer.parseInt(squarestring.substring(index,i));
            if(x>target){
                continue;
            }
            if(cansplit(squarestring,i,target-x)){
                return true;
            }
            
            
        }
        return false;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        
        System.out.println(punishmentNumber(n));
    }
}




You are given a 0-indexed string pattern of length n consisting of the 
characters 'I' meaning increasing and 'D' meaning decreasing.

A 0-indexed string num of length n + 1 is created using the following conditions:

num consists of the digits '1' to '9', where each digit is used at most once.
If pattern[i] == 'I', then num[i] < num[i + 1].
If pattern[i] == 'D', then num[i] > num[i + 1].
Return the lexicographically smallest possible string num that meets the 
conditions.

case=1
input=IIIDIDDD
output=123549876
Explanation:
At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].
At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].
Some possible values of num are "245639871", "135749862", and "123849765".
It can be proven that "123549876" is the smallest possible num that meets 
the conditions.
Note that "123414321" is not possible because the digit '1' is used more than once.

case=2
input=DDD
output=4321
Explanation:
Some possible values of num are "9876", "7321", and "8742".
It can be proven that "4321" is the smallest possible num that meets the 
conditions.



You are given a binary array nums.
You can do the following operation on the array any number of times
(possibly zero):
Choose any 3 consecutive elements from the array and flip all of them.

Flipping an element means changing its value from 0 to 1, and from 1 to 0.
Return the minimum number of operations required to make all elements in nums 
equal to 1. If it is impossible, return -1.

case=1
input=6
0 1 1 1 0 0
output=3

Explanation:
We can do the following operations:
Choose the elements at indices 0, 1 and 2. The resulting array is 
nums = [1,0,0,1,0,0].
Choose the elements at indices 1, 2 and 3. The resulting array is 
nums = [1,1,1,0,0,0].
Choose the elements at indices 3, 4 and 5. The resulting array is 
nums = [1,1,1,1,1,1].

case=2
input=4
0 1 1 1
output=-1
Explanation:
It is impossible to make all elements equal to 1.


import java.util.*;
public class test{
    public static int noofoperations(int arr[]){
        int onecount=0;
        int zerocount=0;
        // for(int i=0;i<n;i++){
        //     if(arr[i]==0){
        //         zerocount++;
        //     }
        //     if(arr[i]==1){
        //         onecount++;
        //     }
        // }
        int n=arr.length;
        int operations=0;
        for(int i=0;i<=n-3;i++){
            if(arr[i]==0){
            for(int k=0;k<3;k++){
                
                    arr[i+k]=1-arr[i+k];
                }
                operations++;
                
            }
            
        }
        for(int num:arr){
            if(num==0){
                return -1;
            }
        }
        
            return operations;
        
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(noofoperations(arr));
    }
    
}




A valid IP address consists of exactly four integers separated by single dots. 
Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.

For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses, 
but "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.
Given a string s containing only digits, return all possible valid IP addresses 
that can be formed by inserting dots into s. You are not allowed to reorder or 
remove any digits in s. You may return the valid IP addresses in any order.

case=1
input=25525511135
output=[255.255.11.135, 255.255.111.35]
       
case=2
input=0000
output=[0.0.0.0]


import java.util.*;

public class test {
    public static List<String> validIPAddress(String str) {
        List<String> result = new ArrayList<>();
        backtrack(str, 0, new ArrayList<>(), result);
        return result;
    }

    public static void backtrack(String str, int index, List<String> current, List<String> result) {
        // If we have 4 parts and consumed entire string, add to result
        if (current.size() == 4) {
            if (index == str.length()) {
                result.add(String.join(".", current));
            }
            return; // whether success or not, stop here
        }

        // Try parts of length 1 to 3
        for (int len = 1; len <= 3 && index + len <= str.length(); len++) {
            String part = str.substring(index, index + len);

            // Check leading zero condition: "0" is valid, "00", "01" etc not valid
            if (part.length() > 1 && part.startsWith("0")) {
                continue;
            }

            int num = Integer.parseInt(part);
            if (num >= 0 && num <= 255) {
                current.add(part); // choose
                backtrack(str, index + len, current, result); // explore
                current.remove(current.size() - 1); // backtrack
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        List<String> res = validIPAddress(str);
        for (String ip : res) {
            System.out.println(ip);
        }
        sc.close();
    }
}


Given string num representing a non-negative integer num, and an integer k, 
return the smallest possible integer after removing k digits from num.

case=1
input=1432219
3
output=1219

Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 
which is the smallest.

case=2
input=10200
1
output=200

Explanation: Remove the leading 1 and the number is 200. Note that the output 
must not contain leading zeroes.

case=3
input=10
1
output=0

Explanation: Remove all the digits from the number and it is left with nothing 
which is 0.



import java.util.*;
public class test{
     public static String smallestNumber(String num, int k){


        Stack<Character> stack = new Stack<>();

        for (char digit : num.toCharArray()) 
        {
            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) 

            {
                stack.pop();
                k--;
            }
            stack.push(digit);
        }
        
        while (k > 0) 
            {
            stack.pop();
            k--;
            }

        
        StringBuilder sb = new StringBuilder();
        for (char digit : stack) 
        {
            sb.append(digit);

        }
        // Remove leading zeros
        while (sb.length() > 1 && sb.charAt(0) == '0') 
        {
            sb.deleteCharAt(0);
            }
        return sb.toString();
}
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String num=sc.next();
        int k=sc.nextInt();
        System.out.println(smallestNumber(num, k));
    }
}


Given a string s representing a valid expression, implement a basic 
calculator to evaluate it, and return the result of the evaluation.
Note: You are not allowed to use any built-in function which evaluates 
strings as mathematical expressions, such as eval().

Sample test case

case=1
input=1 + 1
output=2

case=3
input=(1+(4+5+2)-3)+(6+8)
output=23

Constraints:

1 <= s.length <= 3 * 105
s consists of digits, '+', '-', '(', ')', and ' '.
s represents a valid expression.
'+' is not used as a unary operation (i.e., "+1" and "+(2 + 3)" is invalid).
'-' could be used as a unary operation (i.e., "-1" and "-(2 + 3)" is valid).
There will be no two consecutive operators in the input.
Every number and running calculation will fit in a signed 32-bit integer.



import java.util.*;
public class test{
    public static int caluclator(String str){
        int sum=0;
        Deque<Character> st=new ArrayDeque<>();
        for(Character ch:str.toCharArray()){
            if(ch=='('){
                st.push(ch);
            }
            if(ch=='+'){
               st.push(ch);
            }
            if(st.peek()=='+'){
                st.pop();
                st.push(ch-'0'+st.pop()-'0');
            }
            if(st.peek()=='-'){
                st.pop();
               st.push(ch-'0'-st.pop()-'0');
            }
            if(ch==')'){
                int x=st.pop();
                st.pop();
                st.push(x);
            }
            
        }
        while(!st.isEmpty()){
            sum+=st.pop();
        }
        
        return sum;
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.next();
        str.replaceAll(" ","");
        System.out.println(caluclator(str));
    }
}




----------------------practise
Given a string s, partition s such that every substring of the partition 
is a palindrome. Return all possible palindrome partitioning of s.

case=1
input=aab
output=[[a, a, b], [aa, b]]
Explanation: In the above output every substring of the partition 
is a palindrome.

case=2
input=abba
output=[[a, b, b, a], [a, bb, a], [abba]]




import java.util.*;

public class test {

    // Function to check if a string is palindrome
    public static boolean isPalindrome(String str) {
        int left = 0, right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) return false;
            left++;
            right--;
        }
        return true;
    }

    // Backtracking function to generate all palindrome partitions
    public static void backtrack(String s, int start, List<String> currentPartition, List<List<String>> result) {
        if (start == s.length()) {
            // We've reached the end of the string, add the current partition to results
            result.add(new ArrayList<>(currentPartition));
            return;
        }

        // Try all substrings starting at 'start'
        for (int end = start; end < s.length(); end++) {
            String substring = s.substring(start, end + 1);

            if (isPalindrome(substring)) {
                // Choose
                currentPartition.add(substring);
                // Explore
                backtrack(s, end + 1, currentPartition, result);
                // Backtrack
                currentPartition.remove(currentPartition.size() - 1);
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();

        List<List<String>> result = new ArrayList<>();
        backtrack(s, 0, new ArrayList<>(), result);

        System.out.println(result);
    }
}
