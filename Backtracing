*************Loop based**********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use loop based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.


Solution:

import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            backtrack(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
    }
    public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) -
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element 
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
       System.out.println( generateSubsets(arr));
    }
}



**********Binary tree based without recursion********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Binary Tree based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test

{


    public static List<List<Integer>> generateSubsets(int arr[])

{


        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    

}
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result)

{

if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
}



  current.add(arr[i]);
  backtrack(arr,i+1,current,result);
  current.remove(current.size()-1);
  backtrack(arr,i+1,current,result);
    

}
  public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


    public static void main(String[] args)

{


        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)

{


            arr[i]=sc.nextInt();
        

}


       List<List<Integer>> result = generateSubsets(arr);

    sortListOfList(result);  // Sort the list of subsets

    System.out.println(result);
    

}

}



**********Binary tree with the recursion************
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Pure Recursion based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result){
    if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
    }
  List<Integer> includelist=new ArrayList<>(current);
  includelist.add(arr[i]);
  backtrack(arr,i+1,includelist,result);
  List<Integer> excludelist=new ArrayList<>(current);
  backtrack(arr,i+1,excludelist,result);
}
 public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
{
            arr[i]=sc.nextInt();
}
       List<List<Integer>> result = generateSubsets(arr);
    sortListOfList(result);  // Sort the list of subsets
    System.out.println(result);
}

}




*************NOW ACTUAL Hard Problems will start*********
The XOR total of an array is defined as the bitwise XOR of all its elements, 
or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting 
some (possibly zero) elements of b. 

Sample test case

case=1
input=2
1 3
output=6

Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6

case=2
input=3
5 1 6
output=28

Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

case=3
input=6
3 4 5 6 7 8
output=480

case=4
input=5
1 3 5 7 9
output=240

solution:

import java.util.*;
public class test{
    public static List<List<Integer>> subsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        recursionxor(arr,0,current,result);
        return result;
    }
    public static void recursionxor(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            recursionxor(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
        
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        // System.out.println(subsets(arr));
        List<List<Integer>> allSubsets = subsets(arr);
        int totalXorSum = 0;

        for (List<Integer> subset : allSubsets) 
            {
            int xor = 0;
            for (int num : subset) 
            {
                xor ^= num;
            }
            totalXorSum += xor;
            }
        System.out.println( totalXorSum);
    }
}


----------------------------Mixed Data structure problems-------------
/*
Given the root of a binary tree, return all root-to-leaf paths in any order.
A leaf is a node with no children.

Note: A Binary tree data structure is built from the user input and the root 
node is provided, you just need to implement the binaryTreePaths ()
An array element having value -1 represents NULL.

Sample test case
input=5
1 2 3 -1 5
output=[[1, 2, 5], [1, 3]]

      1
     / \
    2   3
     \
      5

Explanation: There are two paths from root to lead are 1->2->5 and 1->3

input=1
1
output=[[1]]


*/


import java.util.*;
class Solution
{
    List<List<Integer>> binaryTreePaths(Node node)
    {
        // Implement your code here     
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        // if(node==null){
        //     return result;
        // }
      backtrack(node,temp,result);
       
      
       
       return result;
    }
    public void backtrack(Node node,List<Integer> current,List<List<Integer>> result){
        if(node==null){
            return;
        }
        current.add(node.data);
        if(node.left==null && node.right==null){
            result.add(new ArrayList<>(current));
            
        }
        
        else{
         backtrack(node.left,current,result);
         
       backtrack(node.right,current,result);
        }
       current.remove(current.size()-1);
       
    }
}





/*
Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, f
ind all possible paths from node 0 to node n - 1 and return them in any order.

A graph is created and represented in the form of adjacency list is provided.
Note: you just need to implement the allPaths() method.

case=1
input=4 4
0 1
0 2
1 3
2 3
0 3
output=[[0, 1, 3], [0, 2, 3]]

Explanation: The first line contains number of nodes and number of edges. 
Followed by edges (start, end). Finally, the start node and destination node 
in the graph.

class Graph
{
    int vertices;
    List<Integer> adj[];
}
*/

import java.util.*;
class Solution
{
    // Parameters -> graph, start node, destination node
    List<List<Integer>> allPaths(Graph g, int s, int d)
    {
        // Implement your code here
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(g,s,d,result,temp);
        return result;
        
    }
    public void backtrack(Graph g,int start,int dest,List<List<Integer>> result,List<Integer> temp){
        
        temp.add(start);
        if(start==dest){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int neigh:g.adj[start]){
            backtrack(g,neigh,dest,result,temp);
            temp.remove(temp.size()-1);
            
        }
    }
   
}



Given an array nums of distinct integers, return all the possible permutations. 
You can return the answer in any order.

case=1
input=3
1 2 3
output=[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

Explanation:
Input: The first line is the number of elements, followed by their values.
Output: All possible permutations

case=2
input=2
0 1
output=[[0, 1], [1, 0]]

Note: The below function sorts a list of lists. You can use this to sort the 
subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


Solution:
import java.util.*;
public class test{
    public static List<List<Integer>> permutations(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
         boolean visited[]=new boolean[arr.length];
        backtrack(arr,current,result,visited);
        return result;
    }
    public static void backtrack(int arr[],List<Integer> current,List<List<Integer>> result,boolean visited[]){
       
        if(current.size()==arr.length){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=0;i<arr.length;i++){
            if(!visited[i]){
                visited[i]=true;
                current.add(arr[i]);
                backtrack(arr,current,result,visited);
                current.remove(current.size()-1);
                visited[i]=false;
            }
            // current.add(arr[i]);
            // backtrack(arr,i+1,current,result);
            // current.remove(current.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(permutations(arr));
    }
}





Given a set of positive numbers, determine if there exists a subset whose 
sum is equal to a given number ‘S’.

Example:
Input: {1, 2, 3, 7}, S=6
Output: True

Explanation: The given set has a subset whose sum is '6': {1, 2, 3}

Sample test case
case=1
input=4
1 2 3 7
6
output=true


import java.util.*;
public class test{
    public static boolean isSubset(int arr[],int s){
        int n=arr.length;
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        backtrack(arr,0,result,temp);
        
        
        for(List<Integer> tempsum:result){
            int sum=0;
            for(Integer num:tempsum){
                sum=sum+num;
                if(sum==s){
                    return true;
                }
            }
           
        }
         return false;
    }
    public static void backtrack(int arr[],int start,List<List<Integer>> result,List<Integer> temp){
        result.add(new ArrayList<>(temp));
        for(int i=start;i<arr.length;i++){
            temp.add(arr[i]);
            // int sum+=arr[i];
            backtrack(arr,i+1,result,temp);
            temp.remove(temp.size()-1);
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        
        int s=sc.nextInt();
        System.out.println(isSubset(arr, s));
    }
}


Given a string containing digits from 2-9 inclusive, return all possible 
letter combinations that the number could represent.
A mapping of digits to letters (just like on the telephone buttons) 
is given below. 
2-> a, b, c
3-> d, e, f
4-> g, h, i
5-> j, k, l
6-> m, n, o
7-> p, q, r, s
8-> t, u, v
9-> w, x, y, z

Note that 1 does not map to any letters. The result should be in ascending order.
 

case=1
input=2
output=[a, b, c]

case=2
input=23
output=[ad, ae, af, bd, be, bf, cd, ce, cf]

import java.util.*;

public class test {
    public static List<String> letterCombinations(String str) {
        List<String> result = new ArrayList<>();
        if (str.length() == 0) return result;
        HashMap<Character, String> hm = new HashMap<>();
        hm.put('2', "abc"); hm.put('3', "def"); hm.put('4', "ghi");
        hm.put('5', "jkl"); hm.put('6', "mno"); hm.put('7', "pqrs");
        hm.put('8', "tuv"); hm.put('9', "wxyz");
        backtrack(str, 0, new StringBuilder(), hm, result);
        return result;
    }

    public static void backtrack(String str, int index, StringBuilder path, HashMap<Character, String> hm, List<String> result) {
        if (index == str.length()) {
            result.add(path.toString());
            return;
        }
        String letters = hm.get(str.charAt(index));
        if (letters == null) return;
        for (char letter : letters.toCharArray()) {
            path.append(letter);
            backtrack(str, index + 1, path, hm, result);
            path.deleteCharAt(path.length() - 1);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        List<String> combinations = letterCombinations(str);
        System.out.println(combinations);
    }
}


Given two integers n and k, return all possible combinations of k numbers 
chosen from the range [1, n].
You may return the answer in any order.

case=1
input=4 2
output=[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered 
to be the same combination.

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
{
    Collections.sort(Subsets, (a, b) ->
    {
        int sizeA = a.size();
        int sizeB = b.size();

        // Compare element by element
        for (int i = 0; i < Math.min(sizeA, sizeB); i++)
        {
            if (!a.get(i).equals(b.get(i)))
            {
                return a.get(i) - b.get(i);
            }
        }

        // If all elements are equal, compare by size
        return sizeA - sizeB;
    });
}

case=2
input=1 1
output=[[1]]
Explanation: There is 1 choose 1 = 1 total combination.



import java.util.*;
public class test{
    public static List<List<Integer>> combinations(int n,int k){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(n,k,result,current,1);
        sortListOfList(result);
        return result;
    }
    public static void backtrack(int n,int k,List<List<Integer>> result,List<Integer> current,int start){
        
        if(current.size()==k){
            result.add(new ArrayList<>(current));
            return;
        }
        for(int i=start;i<=n;i++){
            current.add(i);
            backtrack(n,k,result,current,i+1);
            current.remove(current.size()-1);
            }
        }
    
    public static void sortListOfList(List<List<Integer>> result)
{
    Collections.sort(result, (a, b) ->
    {
        int sizeA = a.size();
        int sizeB = b.size();

        // Compare element by element
        for (int i = 0; i < Math.min(sizeA, sizeB); i++)
        {
            if (!a.get(i).equals(b.get(i)))
            {
                return a.get(i) - b.get(i);
            }
        }

        // If all elements are equal, compare by size
        return sizeA - sizeB;
    });
}
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        System.out.println(combinations(n,k));
        
    }
}



Given an array of distinct integers candidates and a target integer target, 
return a list of all unique combinations of candidates where the chosen numbers 
sum to target. You may return the combinations in any order.

The same number may be chosen from candidates an unlimited number of times. 
Two combinations are unique if the frequency of at least one of the chosen 
numbers is different.

The test cases are generated such that the number of unique combinations that 
sum up to target is less than 150 combinations for the given input.

case=1
input=4
2 3 8 7
7
output=[[2, 2, 3], [7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

case=2
input=3
2 3 5
8
output=[[2, 2, 2, 2], [2, 3, 3], [3, 5]]

case=3
input=1
2
1
output=[]



import java.util.*;
public class test{
    public static List<List<Integer>> combinations(int arr[],int target){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> temp=new ArrayList<>();
        
        
        backtrack(arr,0,temp,result,target);
        return result;
    }
    public  static void backtrack(int arr[],int index,List<Integer> temp,List<List<Integer>> result,int target){
        
        if(target==0){
            result.add(new ArrayList<>(temp));
            return;
        }
        if(target<0){
            return;
        }
        for(int i=index;i<arr.length;i++){
            temp.add(arr[i]);
            backtrack(arr,i,temp,result,target-arr[i]);
            temp.remove(temp.size()-1);
            
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
            
        }
        int target=sc.nextInt();
        System.out.println(combinations(arr,target));
    }
}




The n-queens puzzle is the problem of placing n queens on an n x n chessboard 
such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle. 
You may return the answer in any order.
Each solution contains a distinct board configuration of the n-queens' 
placement, where 'Q' and '.' both indicate a queen and an empty space, 
respectively.

case=1
input=4
output=[[.Q.., ...Q, Q..., ..Q.], [..Q., Q..., ...Q, .Q..]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as 
shown above

case=2
input=1
output=[[Q]]


import java.util.*;
public class test{
    public static void solveNQueens(int n) {
        List<List<String>> results = new ArrayList<>();
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        solve(0, board, results, n);
        System.out.print(results);
    }
    static void solve(int row, char[][] board, List<List<String>> results, int n) {
        if (row == n) {
            results.add(constructBoard(board));
            return;
            }

        for (int col = 0; col < n; col++){
            if (isSafe(row, col, board, n)){
                board[row][col] = 'Q';
                solve(row + 1, board, results, n);
                board[row][col] = '.';
            }
        }
    }
    private static boolean isSafe(int row, int col, char[][] board, int n) {
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
            }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
                }
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
            if (board[i][j] == 'Q') return false;
            }

        return true;
        }

    private static List<String> constructBoard(char[][] board){
        List<String> al = new ArrayList<>();
        for (char[] row : board){

            al.add(new String(row));
            }
        return al;
        }
 public static void main(String[] args) {
       Scanner sc = new Scanner(System.in);
       int n = sc.nextInt();
       solveNQueens(n);
    
}

}







Given n pairs of parentheses, write a function to generate all combinations 
of well-formed parentheses.

case=1
input=3
output=[((())), (()()), (())(), ()(()), ()()()]

case=2
input=1
output=[()]


import java.util.*;
public class test

{


    public static List<String> generateParenthesis(int n)

{


        List<String> result=new ArrayList<>();
        if(n==0)

{


            return result;
        

}
        backtrack(n,0,0,new StringBuilder(""),result);
        return result;
    

}
    
    private static void backtrack(int n,int open,int close,StringBuilder path,List<String> result)

{


        
        if(path.length()==2*n)

{


            result.add(path.toString());
            return;
        

}
        
        if(open<n)

{
          
          
            path.append('(');
            backtrack(n,open+1,close,path,result);
            path.deleteCharAt(path.length()-1);
        

}
        if(close<open)

{           
    

            path.append(")");
            backtrack(n,open,close+1,path,result);
            path.deleteCharAt(path.length()-1);
}
}
    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(generateParenthesis(n));

}

}



