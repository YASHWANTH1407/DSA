*************Loop based**********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use loop based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.


Solution:

import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int start,List<Integer> current,List<List<Integer>> result){
        result.add(new ArrayList<>(current));
        for(int i=start;i<arr.length;i++){
            current.add(arr[i]);
            backtrack(arr,i+1,current,result);
            current.remove(current.size()-1);
        }
    }
    public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) -
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element 
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
       System.out.println( generateSubsets(arr));
    }
}



**********Binary tree based without recursion********
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Binary Tree based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test

{


    public static List<List<Integer>> generateSubsets(int arr[])

{


        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    

}
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result)

{

if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
}



  current.add(arr[i]);
  backtrack(arr,i+1,current,result);
  current.remove(current.size()-1);
  backtrack(arr,i+1,current,result);
    

}
  public static void sortListOfList(List<List<Integer>> result)
    {
        Collections.sort(result, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }


    public static void main(String[] args)

{


        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)

{


            arr[i]=sc.nextInt();
        

}


       List<List<Integer>> result = generateSubsets(arr);

    sortListOfList(result);  // Sort the list of subsets

    System.out.println(result);
    

}

}



**********Binary tree with the recursion************
Given an integer array nums of unique elements, return all possible 
subsets (the power set).

Note: Use Pure Recursion based backtracking approach.

The solution set must not contain duplicate subsets.

Sample test cases
case=1
input=3
1 2 3
output=[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]

case=2
input=1
1
output=[[], [1]]

Note: The below function, sorts a list of lists. You can use this function to 
sort the subsets generated by your code.

public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }




import java.util.*;
public class test{
    public static List<List<Integer>> generateSubsets(int arr[]){
        List<List<Integer>> result=new ArrayList<>();
        List<Integer> current=new ArrayList<>();
        backtrack(arr,0, current,result);
        return result;
    }
    public static void backtrack(int arr[],int i,List<Integer> current,List<List<Integer>> result){
    if(i==arr.length){
    result.add(new ArrayList<>(current));
    return;
    }
  List<Integer> includelist=new ArrayList<>(current);
  includelist.add(arr[i]);
  backtrack(arr,i+1,includelist,result);
  List<Integer> excludelist=new ArrayList<>(current);
  backtrack(arr,i+1,excludelist,result);
}
 public static void sortListOfList(List<List<Integer>> Subsets)
    {
        Collections.sort(Subsets, (a, b) ->
        {
            int sizeA = a.size();
            int sizeB = b.size();

            // Compare element by element
            for (int i = 0; i < Math.min(sizeA, sizeB); i++)
            {
                if (!a.get(i).equals(b.get(i)))
                {
                    return a.get(i) - b.get(i);
                }
            }

            // If all elements are equal, compare by size
            return sizeA - sizeB;
        });
    }

    public static void main(String[] args)
{
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
{
            arr[i]=sc.nextInt();
}
       List<List<Integer>> result = generateSubsets(arr);
    sortListOfList(result);  // Sort the list of subsets
    System.out.println(result);
}

}




*************NOW ACTUAL Hard Problems will start*********
The XOR total of an array is defined as the bitwise XOR of all its elements, 
or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting 
some (possibly zero) elements of b. 

Sample test case

case=1
input=2
1 3
output=6

Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6

case=2
input=3
5 1 6
output=28

Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

case=3
input=6
3 4 5 6 7 8
output=480

case=4
input=5
1 3 5 7 9
output=240

solution:








