//Krushkals algorithm

import java.util.*;

class test{
    static class UF{
        int[] parent;
        int[] rank;
        int count;
        
        public UF(int n){
            parent = new int[n];
            rank = new int[n];
            for(int i = 0 ; i < n; i++){
                parent[i] = i;
                rank[i] = 1;
            }
            count = n;
        }
        
        public void union(int x,int y){
            int a = find(x);
            int b= find(y);
            
            if(a!=b){
                if(rank[a]>rank[b]){
                    parent[b]=a;
                }
                else if(rank[b]>rank[a]){
                    parent[a]=b;
                }else{
                    parent[a]=b;
                    rank[b]++;
                }
                count--;
            }
        }
        
        public int find(int a){
            if(parent[a]!=a){
                parent[a]= find(parent[a]);
            }
            return parent[a];
        }
    }
    static class Edge{
        int src,dest,weight;
        @Override
        public  String toString(){
            return "["+src+","+dest+","+ weight+"]";
        }
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int V = sc.nextInt();
        int E = sc.nextInt();
        Edge[] edges = new Edge[E];
        for(int i = 0 ;i<E;i++){
            Edge e = new Edge();
            e.src = sc.nextInt();
            e.dest = sc.nextInt();
            e.weight = sc.nextInt();
            edges[i] = e;
        }
        Arrays.sort(edges,(a,b)->a.weight - b.weight);
        
        UF u = new UF(V);
        List<Edge> mst = new ArrayList<>();
        int totalweight = 0;
        
        for(Edge edge: edges){
            int r1 = u.find(edge.src);
            int r2 = u.find(edge.dest);
            
            if(r1!=r2){
                mst.add(edge);
                totalweight+=edge.weight;
                u.union(r1,r2);
                
            }
            if(mst.size() == V-1){
                break;
            }
        }
        System.out.println(mst);
        System.out.println(totalweight);
        
    }
}



There are n cities labeled from 1 to n. You are given the integer n and an 
array connections where connections[i] = [xi, yi, costi] indicates that the 
cost of connecting city xi and city yi (bidirectional connection) is costi.

Return the minimum cost to connect all the n cities such that there is at 
least one path between each pair of cities. If it is impossible to connect 
all the n cities, return -1,

The cost is the sum of the connections' costs used.

case=1
input=3 3
1 2 5
1 3 6
2 3 1
output=6

Explanation: 
Input: Number of vertices, followed by number of edges, followed by values 
for edges.
Choosing any 2 edges will connect all cities so we choose the minimum 2.

case=2
input=4 2
1 2 3
3 4 4
output=-1

Explanation: There is no way to connect all cities even if all edges are used.




import java.util.*;

class test{
    static class UF{
        int[] parent;
        int[] rank;
        int count;
        
        public UF(int n){
            parent = new int[n];
            rank = new int[n];
            for(int i = 0 ; i < n; i++){
                parent[i] = i;
                rank[i] = 1;
            }
            count = n;
        }
        
        public void union(int x,int y){
            int a = find(x);
            int b= find(y);
            
            if(a!=b){
                if(rank[a]>rank[b]){
                    parent[b]=a;
                }
                else if(rank[b]>rank[a]){
                    parent[a]=b;
                }else{
                    parent[a]=b;
                    rank[b]++;
                }
                count--;
            }
        }
        
        public int find(int a){
            if(parent[a]!=a){
                parent[a]= find(parent[a]);
            }
            return parent[a];
        }
    }
    static class Edge{
        int src,dest,weight;
        @Override
        public  String toString(){
            return "["+src+","+dest+","+ weight+"]";
        }
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int V = sc.nextInt();
        int E = sc.nextInt();
        Edge[] edges = new Edge[E];
        for(int i = 0 ;i<E;i++){
            Edge e = new Edge();
            e.src = sc.nextInt();
            e.dest = sc.nextInt();
            e.weight = sc.nextInt();
            edges[i] = e;
        }
        Arrays.sort(edges,(a,b)->a.weight - b.weight);
        
        UF u = new UF(V+1);
        List<Edge> mst = new ArrayList<>();
        int totalweight = 0;
        
        for(Edge edge: edges){
            int r1 = u.find(edge.src);
            int r2 = u.find(edge.dest);
            
            if(r1!=r2){
                mst.add(edge);
                totalweight+=edge.weight;
                u.union(r1,r2);
                
            }
            
            if(mst.size() == V-1){
                
                break;
               
            }
        }
        if(mst.size() == V-1){
                
                System.out.println(totalweight);
               
            }
            else{
                 System.out.println("-1");
            }
        }
        
       
        
    }




