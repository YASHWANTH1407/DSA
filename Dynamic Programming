The Fibonacci numbers, commonly denoted F(n) form a sequence, called the 
Fibonacci sequence, such that each number is the sum of the two preceding 
ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

case=1
input=2
output=1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

case=2
input=3
output=2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

case=3
input=60
output=1548008755920


import java.util.*;
public class test{
    public static   int  fib(int n, int dp[]){
        if(n==0){
            return 0;
        }
        else if(n==1){
            return 1;
        }
        if(dp[n]!=-1){
            return dp[n];
        }
        
        dp[n]=fib(n-1,dp)+fib(n-2,dp);
        return dp[n];
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
         int dp[]=new int[n+1];
        Arrays.fill(dp,-1);
        System.out.println(fib(n,dp));
    }
}

You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can 
you climb to the top?

Sample test cases

case=1
input=2
output=2

Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

case=2
input=3
output=3

Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

case=6
input=60
output=2504730781961


import java.util.*;
public class test{
    public static long ways(int n,long dp[]){
        if(n==0){
            return 1;
        }
        if(n==1 || n==2){
            return n;
        }
        if(dp[n]!=-1){
            return dp[n];
        }
        dp[n]=ways(n-1,dp)+ways(n-2,dp);
        
        return dp[n];
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        long dp[]=new long[n+1];
        Arrays.fill(dp,-1);
        System.out.println(ways(n,dp));
    }
}


You are given an integer array coin representing coins of different 
denominations and an integer amount representing a total amount of money.
Return the few`est number of coins that you need to make up that amount. 
If that amount of money cannot be made up by any combination of the 
coins, return -1.
You may assume that you have an infinite number of each kind of coin.

Sample test case

case=1
input=3
1 2 5
11
output=3

case=2
input=1
2
3
output=-1

case=3
input=4
9 6 5 1
11
output=2


import java.util.*;
public class test{
    public static int ways(int arr[],int dp[],int target){
      
      if(target==0){
          return 0;
      }
      if(target<0){
          return -1;
      }
      if(dp[target]!=-1){
          return dp[target];
      }
      

int min=Integer.MAX_VALUE;
      
     for(int i=0;i<arr.length;i++){
         int result=ways(arr,dp,target-arr[i]);
         
        if(result!=-1){
            min=Math.min(min,result+1);
        
    }
    

}

        dp[target]=(min==Integer.MAX_VALUE)?-1:min;
        

    return dp[target];


}
    
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int target=sc.nextInt();
        int dp[]=new int[target+1];
        Arrays.fill(dp,-1);
        System.out.println(ways(arr,dp,target));
    }
}




